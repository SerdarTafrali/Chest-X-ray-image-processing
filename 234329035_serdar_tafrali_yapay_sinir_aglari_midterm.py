# -*- coding: utf-8 -*-
"""234329035_SERDAR_TAFRALI_YAPAY_SINIR_AGLARI_MIDTERM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17fjMcYcfUrbvqbJjSC_zMhDQCaYVWn5J

# MLP ve RBF Ağları Kullanarak Sınıflandırma Uygulaması

Bu proje, **Çok Katmanlı Algılayıcılar (MLP)** ve **Radial Basis Function (RBF)** ağlarını kullanarak bir sınıflandırma uygulaması yapmayı hedeflemektedir. Adım adım veri ön işleme, model eğitimi, hiperparametre optimizasyonu ve performans değerlendirmesi yapılacaktır.

## İçerik

### 1. Gerekli Kütüphanelerin Yüklenmesi
- `pandas`, `numpy` (veri işleme)
- `sklearn`, `keras` (model oluşturma, veri ayırma, performans metrikleri)
- `matplotlib` ve `seaborn` (görselleştirme)

### 2. Veri Seti Yükleme ve Ön İşleme
1. **Veri Yükleme**
2. **Eksik Değerlerin İşlenmesi**
   - Eğer veri setinde eksik değerler varsa, uygun yöntemlerle doldurulmalıdır.
3. **Veri Setini Eğitim ve Test Olarak Ayırma**
   - Veriyi %80 eğitim, %20 test olarak ikiye ayırın.
   - `sklearn.model_selection.train_test_split` fonksiyonunu kullanın.
4. **Özellik Ölçekleme (Feature Scaling)**
   - Verileri MLP ve RBF için uygun hale getirmek adına standartlaştırın (örn. `StandardScaler` veya `MinMaxScaler` kullanarak).

### 3. Model Eğitimi ve Hiperparametre Denemeleri
1. **MLP Modeli**
   - `sklearn.neural_network.MLPClassifier` kullanarak bir MLP modeli oluşturun.
   - Hiperparametre denemeleri için farklı katman sayıları, nöron sayıları ve aktivasyon fonksiyonlarını test edin (örn. `hidden_layer_sizes`, `activation` ve `learning_rate` gibi parametreler).
2. **RBF Modeli**
   - `sklearn` kütüphanesinde doğrudan RBF modeli bulunmadığından, `Keras` kütüphanesi kullanın.
   - Alternatif olarak, `rbfnetwork` gibi özel kütüphaneler veya Python’da yazılmış RBF fonksiyonları kullanılabilir.

### 4. Performans Ölçümleri
1. **Confusion Matrix**
   - Her iki model için tahminleri değerlendirerek karışıklık matrisini (`confusion_matrix`) oluşturun.
   - `seaborn` kullanarak karışıklık matrisini görselleştirin.
2. **Performans Metrikleri**
   - Her iki model için `accuracy`, `precision`, `recall`, ve `F1-score` gibi metrikleri hesaplayın (`sklearn.metrics.classification_report` fonksiyonunu kullanarak).

### 5. Hiperparametre Denemeleri ve Sonuçları Karşılaştırma
1. **Hiperparametre Denemeleri**
   - MLP ve RBF modelleri için farklı hiperparametreleri deneyin ve her denemede eğitim ve test sonuçlarını kaydedin.
   - `GridSearchCV` veya `RandomizedSearchCV` ile hiperparametre optimizasyonu yaparak en iyi parametreleri bulun.
2. **Sonuçları Karşılaştırma ve Yorumlama**
   - MLP ve RBF modellerinin sonuçlarını karşılaştırarak hangi modelin daha iyi performans gösterdiğini analiz edin.
   - Sonuçları tablo veya grafik olarak sunun ve performans farklılıklarının nedenlerini tartışın.

# 1. Gerekli Kütüphanelerin Yüklenmesi
"""

# pip install scikeras

# Gerekli Kütüphanelerin Yüklenmesi

import numpy as np
import pandas as pd

# Veri ayırma ve performans metrikleri için
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.metrics import confusion_matrix, classification_report

# MLP ve RBF modelleri için Keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Flatten, Input, Layer
from tensorflow.keras.utils import to_categorical, register_keras_serializable
from scikeras.wrappers import KerasClassifier
import tensorflow.keras.backend as K

# Özellik ölçekleme için
from sklearn.preprocessing import StandardScaler, MinMaxScaler

# Görselleştirme için
import matplotlib.pyplot as plt
import seaborn as sns

# PyTorch ve torchvision
import torch
import torchvision
from torchvision.datasets import GTSRB
import torchvision.transforms as transforms

"""# 2. Veri Seti Yükleme ve Ön İşleme

## 1. Veri Setinin Yüklenmesi
"""

# 2. Veri Seti Yükleme ve Ön İşleme

# Dönüşümler (Transforms)
transform = transforms.Compose([
    transforms.Resize((32, 32)),
    transforms.ToTensor(),
])

# Veri Setini Yükleme
train_dataset = GTSRB(root='.', split='train', transform=transform, download=True)
test_dataset = GTSRB(root='.', split='test', transform=transform, download=True)

"""## 2. Veri Ön İşleme"""

# Veri Setini NumPy Dizilerine Dönüştürme

def dataset_to_arrays(dataset):
    data = []
    targets = []
    for img, label in dataset:
        data.append(img.numpy())
        targets.append(label)
    data = np.array(data)
    targets = np.array(targets)
    return data, targets

# Eğitim ve Test Verilerini Dönüştürme
X_train, y_train = dataset_to_arrays(train_dataset)
X_test, y_test = dataset_to_arrays(test_dataset)

print("Eğitim verisi şekli:", X_train.shape)
print("Eğitim etiketleri şekli:", y_train.shape)

# Veriyi Yeniden Şekillendirme

# Keras modelleri genellikle (num_samples, height, width, channels) şeklinde veri bekler
# Ancak scikit-learn modelleri için veriyi düzleştirmemiz gerekir

# MLP için veriyi düzleştirme
X_train_flat = X_train.reshape(X_train.shape[0], -1)
X_test_flat = X_test.reshape(X_test.shape[0], -1)

print("Düzleştirilmiş eğitim verisi şekli:", X_train_flat.shape)

# Özellik Ölçekleme (Feature Scaling)

scaler = StandardScaler()
X_train_flat = scaler.fit_transform(X_train_flat)
X_test_flat = scaler.transform(X_test_flat)

# Etiketleri Kategorik Hale Getirme

num_classes = len(np.unique(y_train))
y_train_cat = to_categorical(y_train, num_classes)
y_test_cat = to_categorical(y_test, num_classes)

"""# 3. Model Eğitimi ve Hiperparametre Denemeleri

## 1. MLP Modeli
"""

# MLP Modeli Oluşturma ve Eğitme

def create_mlp_model(hidden_layers=(100,), activation='relu', learning_rate=0.001):
    model = Sequential()
    model.add(Input(shape=(X_train_flat.shape[1],)))
    for units in hidden_layers:
        model.add(Dense(units=units, activation=activation))
    model.add(Dense(num_classes, activation='softmax'))
    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    return model

# KerasClassifier ile modeli sarmalama
mlp_model = KerasClassifier(
    model=create_mlp_model,
    hidden_layers=(100,),
    activation='relu',
    epochs=10,
    batch_size=32,
    verbose=1
)

# Modeli Eğitme
mlp_model.fit(X_train_flat, y_train_cat)

"""## 2. RBF Modeli"""

# RBF Katmanı Tanımlama

import tensorflow.keras.backend as K

class RBFLayer(Layer):
    def __init__(self, units, gamma, **kwargs):
        super(RBFLayer, self).__init__(**kwargs)
        self.units = units
        self.gamma = K.constant(gamma)

    def build(self, input_shape):
        self.mu = self.add_weight(name='mu',
                                  shape=(self.units, input_shape[-1]),
                                  initializer='uniform',
                                  trainable=True)
        super(RBFLayer, self).build(input_shape)

    def call(self, inputs):
        diff = K.expand_dims(inputs, axis=1) - K.expand_dims(self.mu, axis=0)
        l2 = K.sum(K.pow(diff, 2), axis=-1)
        res = K.exp(-self.gamma * l2)
        return res

# RBF Modelini Oluşturma Fonksiyonu
def create_rbf_model(units=100, gamma=0.1):
    model = Sequential()
    model.add(Input(shape=(X_train_flat.shape[1],)))
    model.add(RBFLayer(units=units, gamma=gamma))
    model.add(Dense(num_classes, activation='softmax'))
    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    return model

# KerasClassifier ile modeli sarmalama
rbf_model = KerasClassifier(
    model=create_rbf_model,
    units=100,
    gamma=0.1,
    epochs=20,
    batch_size=32,
    verbose=1
)

# Modeli Eğitme
rbf_model.fit(X_train_flat, y_train_cat)

"""# 4. Performans Ölçümleri

## 1. MLP Modeli için Confusion Matrix ve Performans Metrikleri
"""

# MLP Modeli Tahmin ve Değerlendirme

y_pred_mlp = mlp_model.predict(X_test_flat)
y_pred_mlp_labels = np.argmax(y_pred_mlp, axis=1)

print("MLP Modeli Performans Metrikleri:")
print(classification_report(y_test, y_pred_mlp_labels))

# Confusion Matrix için
cm_mlp = confusion_matrix(y_test, y_pred_mlp_labels)
plt.figure(figsize=(12,10))
sns.heatmap(cm_mlp, annot=True, fmt='d', cmap='Blues')
plt.title('MLP Confusion Matrix')
plt.ylabel('Gerçek Değerler')
plt.xlabel('Tahmin Edilen Değerler')
plt.show()

"""## 1. RBF Modeli için Confusion Matrix ve Performans Metrikleri"""

# RBF Modeli Tahmin ve Değerlendirme

y_pred_rbf = rbf_model.predict(X_test_flat)
y_pred_rbf_labels = np.argmax(y_pred_rbf, axis=1)

print("RBF Modeli Performans Metrikleri:")
print(classification_report(y_test, y_pred_rbf_labels))

# Confusion Matrix için
cm_rbf = confusion_matrix(y_test, y_pred_rbf_labels)
plt.figure(figsize=(12,10))
sns.heatmap(cm_rbf, annot=True, fmt='d', cmap='Blues')
plt.title('RBF Confusion Matrix')
plt.ylabel('Gerçek Değerler')
plt.xlabel('Tahmin Edilen Değerler')
plt.show()

"""# 5. Hiperparametre Denemeleri ve Sonuçların Karşılaştırılması

## 5.1 MLP Modeli için Hiperparametre Optimizasyonu
"""

# MLP Modeli için Hiperparametre Optimizasyonu

param_grid_mlp = {
    'hidden_layers': [(100,), (200,), (100, 50)],
    'activation': ['relu', 'tanh'],
    'epochs': [5],
    'batch_size': [32],
}

grid_mlp = GridSearchCV(estimator=mlp_model, param_grid=param_grid_mlp, cv=3, n_jobs=-1)
grid_mlp.fit(X_train_flat, y_train_cat)
print("En İyi MLP Parametreleri:", grid_mlp.best_params_)

"""## 5.2 RBF Modeli için Hiperparametre Optimizasyonu"""

@register_keras_serializable()
class RBFLayer(Layer):
    def __init__(self, units, gamma, **kwargs):
        super(RBFLayer, self).__init__(**kwargs)
        self.units = units
        self.gamma = K.constant(gamma)

    def build(self, input_shape):
        self.mu = self.add_weight(name='mu',
                                  shape=(self.units, input_shape[-1]),
                                  initializer='uniform',
                                  trainable=True)
        super(RBFLayer, self).build(input_shape)

    def call(self, inputs):
        diff = K.expand_dims(inputs, axis=1) - K.expand_dims(self.mu, axis=0)
        l2 = K.sum(K.pow(diff, 2), axis=-1)
        res = K.exp(-self.gamma * l2)
        return res

# RBF Modelini Oluşturma Fonksiyonu
def create_rbf_model(units=100, gamma=0.1):
    model = Sequential()
    model.add(Input(shape=(X_train_flat.shape[1],)))
    model.add(RBFLayer(units=units, gamma=gamma))
    model.add(Dense(num_classes, activation='softmax'))
    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    return model

# KerasClassifier ile modeli sarmalama
rbf_model = KerasClassifier(
    model=create_rbf_model,
    units=100,
    gamma=0.1,
    epochs=10,
    batch_size=32,
    verbose=1
)

# RBF Modeli için Hiperparametre Optimizasyonu

param_grid_rbf = {
    'model__units': [50, 100],
    'model__gamma': [0.1, 0.5],
    'epochs': [5],
    'batch_size': [32],
}

grid_rbf = GridSearchCV(estimator=rbf_model, param_grid=param_grid_rbf, cv=3, n_jobs=-1)
grid_rbf.fit(X_train_flat, y_train_cat)
print("En İyi RBF Parametreleri:", grid_rbf.best_params_)

"""## Sonuçların karşılaştırılması ve Yorumlama"""

# En İyi MLP Modeli ile Tahmin ve Değerlendirme
best_mlp = grid_mlp.best_estimator_
y_pred_best_mlp = best_mlp.predict(X_test_flat)
y_pred_best_mlp_labels = np.argmax(y_pred_best_mlp, axis=1)

print("En İyi MLP Modeli Performans Metrikleri:")
print(classification_report(y_test, y_pred_best_mlp_labels))

# En İyi RBF Modeli ile Tahmin ve Değerlendirme
best_rbf = grid_rbf.best_estimator_
y_pred_best_rbf = best_rbf.predict(X_test_flat)
y_pred_best_rbf_labels = np.argmax(y_pred_best_rbf, axis=1)

print("En İyi RBF Modeli Performans Metrikleri:")
print(classification_report(y_test, y_pred_best_rbf_labels))

"""## 5.4 Sonuçların Görselleştirilmesi"""

# Performans Metriklerinin Karşılaştırılması

# MLP ve RBF modellerinin doğruluk değerlerini bir arada gösterelim
accuracy_mlp = grid_mlp.best_score_
accuracy_rbf = grid_rbf.best_score_

models = ['MLP', 'RBF']
accuracies = [accuracy_mlp, accuracy_rbf]

plt.bar(models, accuracies, color=['blue', 'green'])
plt.title('MLP ve RBF Modellerinin Doğruluk Karşılaştırması')
plt.ylabel('Doğruluk')
plt.show()

